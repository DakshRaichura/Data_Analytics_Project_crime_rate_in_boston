# -*- coding: utf-8 -*-
"""B08-Analysing-Socioeconomic-Correlates-Of-Crime-Incidents-In-Boston.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_KWvRn4wld6dY98S9-YR0EV4OQLN_boo

#**Analysing Socioeconomic Correlates of Crime Incidents in Boston**
Team8:
*   Yuanhao Li
*   Anton Falk
*   Daksh Raichura
*   Kaixin Gao
*   Keifei Zhang
*   Li Hsin Chang

## I. Executive Summary

---
---


## Objectives and Methods
This analysis investigates how socioeconomic inequality influences crime patterns across Boston’s police districts. By integrating Boston Police Department crime incident data with socioeconomic indicators from the American Community Survey (ACS), the study examines correlations between income, poverty, and crime levels over both spatial and temporal dimensions. Multiple analytical techniques—ranging from regression analysis and quartile comparison to geospatial and time-based visualizations—were employed to uncover relationships between economic disparity and crime concentration. The objective is to provide data-driven insights for policymakers, law enforcement, and community organizations to guide targeted intervention strategies.

## Key Findings
Across all analyses, the results reveal a consistent and measurable link between economic disadvantage and elevated crime rates.  
- **Income and Poverty Correlation:** Low-income and high-poverty districts (notably B2, D4, and C11) account for a disproportionately large share of total crimes. Regression results confirm that poverty has a positive correlation with crime, while higher household income correlates with lower crime rates.  
- **Crime Type Differentiation:** Property and administrative offenses dominate citywide, yet violent crimes are more prevalent in low-income areas. In contrast, high-income communities report fewer serious crimes, primarily involving property or service-related incidents.  
- **Spatial and Temporal Patterns:** Crime hotspots cluster in economically disadvantaged neighborhoods such as Roxbury, Dorchester, and Mattapan. Temporal analyses reveal that crime peaks during summer months and nighttime hours, with distinct variations between residential and commercial zones.  
- **Income Disparity and Crime Intensity:** Quartile-based comparisons demonstrate that districts with the highest poverty or unemployment rates have nearly double the crime rates of wealthier areas. The poorer the socioeconomic conditions, the higher the exposure to violent and property crimes.  
- **Longitudinal Stability:** Between 2020 and 2022, the relationship between socioeconomic status and crime remained structurally stable. Despite minor fluctuations, high-poverty and low-income communities consistently experienced the highest crime burdens.

## Strategic Recommendations
These findings underscore that socioeconomic inequality is not only a statistical correlate but a structural driver of urban crime.  
- **Targeted Community Investment:** Increase funding for education, youth employment, and social welfare programs in districts with high poverty and crime concentration.  
- **Data-Driven Policing:** Deploy predictive and geographically focused policing in persistent crime hotspots, ensuring resource allocation aligns with both crime volume and community needs.  
- **Integrated Policy Response:** Combine law enforcement strategies with housing, public health, and economic development initiatives to mitigate the underlying socioeconomic triggers of crime.  
- **Continuous Monitoring:** Establish a longitudinal data platform linking socioeconomic indicators with crime metrics to track progress and refine intervention strategies annually.

In summary, this report provides a comprehensive, evidence-based understanding of how economic disparity shapes urban crime patterns in Boston. Addressing these disparities through targeted, data-informed policy actions can foster safer and more equitable communities citywide.

## II. Introduction

---

---

### Problem Statement

---

Urban crime is a persistent challenge that shapes both community well-being and policy decisions. In Boston, neighborhood-level socioeconomic conditions—such as income inequality and poverty—play a central role in influencing crime patterns. This project investigates how socioeconomic disadvantages are linked to crime incidents across the city. By combining crime data from the Boston Police Department with U.S. Census Bureau estimates of income and poverty, the analysis aims to uncover meaningful correlations and spatial disparities. The findings are expected to support data-driven strategies that enhance public safety and promote more equitable city development.

### Motivation

---


This analysis explores how socioeconomic inequality shapes crime patterns across Boston. By combining police incident records with census-based data on income, poverty, and education, it reveals the deep connections between economic conditions and public safety. Readers will gain a clear, data-driven understanding of where and why crime concentrates, how social and economic factors contribute to these disparities, and what strategies could help create safer, more equitable communities.

## III. Data Source



---
---

**Crime Data:** Crime Incident Reports - 2022 From: Boston Police Department

Access: https://data.boston.gov/dataset/crime-incident-reports-august-2015-to-date-source-new-system/resource/313e56df-6d77-49d2-9c49-ee411f10cf58

This dataset contains detailed crime incident records reported by the Boston Police Department, including offense type, date, time, and location. It serves as the foundation of our analysis, allowing us to quantify crime rates, identify patterns by district, and perform temporal and spatial analyses.

**Income Data:** ACS 5-Year Estimates - Median Household Income(ACSST5Y2023.S1901) From: American Community Survey

Access: https://data.census.gov/table/ACSST5Y2023.S1901?g=050XX00US25025$1400000

This dataset provides median household income estimates across Boston census tracts from the American Community Survey. It captures income distribution and socioeconomic disparities, which are critical for examining correlations between wealth levels and crime rates.

**Poverty Data:** ACS 5-Year Estimates - Poverty Status(ACSST5Y2023.S1701) From: American Community Survey

Access: https://data.census.gov/table/ACSST5Y2023.S1701?g=050XX00US25025$1400000

The poverty dataset reports the proportion of individuals living below the poverty line by census tract. It provides a direct socioeconomic indicator for identifying vulnerable areas and analyzing how poverty intensity relates to crime prevalence.

**Census Data:** 2020 Census Tracts in Boston - From: U.S. Census Bureau

Access: https://hub.arcgis.com/datasets/boston::2020-census-tracts-in-boston/explore?showTable=true

This spatial dataset delineates Boston's 2020 census tract boundaries with geographic coordinates. It enables spatial joins between demographic and crime data, ensuring accurate mapping and district-level aggregation.

**Districts Data:** Boston Police Districts GeoData Loading Script From: Analyze Boston

Access: https://data.boston.gov/dataset/police-districts/resource/beead2e5-9d5a-4c74-be5c-65d44f9000f5

This geospatial layer defines the boundaries of Boston's police districts. It is essential for linking socioeconomic data to law enforcement jurisdictions, supporting district-based comparisons of crime rates and socioeconomic conditions.

## IV.  Data importing & Cleaning

---
---

### Import data from Github

---
"""

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import statsmodels.api as sm
import numpy as np
import matplotlib.ticker as mtick
from datetime import datetime
import geopandas as gpd
from shapely.geometry import Point

import pandas as pd
pd.set_option('display.max_columns', None)
pd.set_option('display.max_rows', None)

from google.colab import drive
drive.mount('/content/drive')

crime_file = "https://raw.githubusercontent.com/paddington-L831/Intro-to-Data-Analystics1/refs/heads/main/incident%20of%202022.csv"
poverty_file = "https://raw.githubusercontent.com/paddington-L831/Intro-to-Data-Analystics1/refs/heads/main/ACSST5Y2022.S1701-Data.csv"
income_file = "https://raw.githubusercontent.com/paddington-L831/Intro-to-Data-Analystics1/refs/heads/main/ACSST5Y2022.S1901-Data.csv"

crime_incident = pd.read_csv(crime_file, dtype={0: str})
poverty_status = pd.read_csv(poverty_file)
income = pd.read_csv(income_file)

#show crime_incident
crime_incident.head()

"""### Exploring Missing Value

---
"""

crime_incident.isnull().sum()

poverty_status.isnull().sum()

income.isnull().sum()

#show missing values
import missingno as msno
msno.matrix(crime_incident)

msno.matrix(poverty_status)

msno.matrix(income)

"""So what: we've uploaded the datasets we need and reviewed their information, next step we need to work on cleaning.

### Initial Cleaning

---

This cell loads three datasets (crime, poverty, income) from CSV; cleans crime data(standardize dates, drop invalid rows, extract hour & weekday, normalize district labels); and cleans ACS socioeconomic data (select/rename key columns, type casting, compute poverty rate & income metrics), preparing tidy tables for downstream merging, analysis, and visualization.
"""

import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
import matplotlib.ticker as mtick
from datetime import datetime

#Load datasets
crime_incident = pd.read_csv(crime_file, dtype={'INCIDENT_NUMBER': str, 'OFFENSE_CODE': str})
poverty_status = pd.read_csv(poverty_file)
income = pd.read_csv(income_file)


# Crime Data Cleaning
if not crime_incident.empty:
    # Convert to datetime, coerce errors to NaT
    crime_incident['OCCURRED_ON_DATE'] = pd.to_datetime(crime_incident['OCCURRED_ON_DATE'], errors='coerce')

    # Drop rows where datetime conversion failed
    crime_incident.dropna(subset=['OCCURRED_ON_DATE'], inplace=True)

    # Extract hour and day of week
    crime_incident['HOUR'] = crime_incident['OCCURRED_ON_DATE'].dt.hour
    crime_incident['DAY_OF_WEEK'] = crime_incident['OCCURRED_ON_DATE'].dt.day_name()

    # Clean missing values in DISTRICT
    crime_incident.dropna(subset=['DISTRICT'], inplace=True)
    # Filter out records labeled 'External'
    crime_incident = crime_incident[crime_incident['DISTRICT'] != 'External']
    # Normalize a Outside labeling
    crime_incident.loc[crime_incident['DISTRICT'].str.contains('Outside', na=False), 'DISTRICT'] = 'Outside'


# Socioeconomic Data Cleaning
# Selecte target ACS columns and rename
poverty_columns = {
    'GEO_ID': 'GEO_ID',
    'NAME': 'Neighborhood',
    'S1701_C01_001E': 'Total_Population',
    'S1701_C02_001E': 'Population_Below_Poverty'
}
income_columns = {
    'GEO_ID': 'GEO_ID',
    'NAME': 'Neighborhood',
    'S1901_C01_001E': 'Total_Households',
    'S1901_C01_012E': 'Median_Household_Income'
}

# Convert numeric fields to proper types
if not poverty_status.empty:
    poverty_data = poverty_status[poverty_columns.keys()].rename(columns=poverty_columns)
    poverty_data = poverty_data.iloc[1:]
    for col in ['Total_Population', 'Population_Below_Poverty']:
        poverty_data[col] = pd.to_numeric(poverty_data[col], errors='coerce')
    poverty_data['Poverty_Rate'] = (poverty_data['Population_Below_Poverty'] / poverty_data['Total_Population']) * 100

if not income.empty:
    income_data = income[income_columns.keys()].rename(columns=income_columns)
    income_data = income_data.iloc[1:]
    for col in ['Total_Households', 'Median_Household_Income']:
        income_data[col] = pd.to_numeric(income_data[col], errors='coerce')

crime_incident.info()

income.info()

poverty_status.info()

"""So what: Cleaning ensured consistent formats, accurate socioeconomics; and we need to ensure valid district-level alignment.

### Data Aggregation and Analysis

---

Cells below downloads Boston Police District boundary data from the City of Boston's GIS Open Data portal,
and loads it into a GeoDataFrame using GeoPandas for further analysis and visualization.
"""

!pip -q install geopandas shapely pyogrio rtree

# Import GeoPandas
import geopandas as gpd

# Online GeoJSON URL for Boston Police Districts
url = "https://gisportal.boston.gov/arcgis/rest/services/PublicSafety/OpenData/MapServer/5/query?where=1=1&outFields=*&f=geojson"

# Read remote GeoJSON into a GeoDataFrame
districts = gpd.read_file(url)

print(districts.head())

"""**Boston Census Tract → Police District**
1. Read Boston Police District boundaries (GeoJSON via ArcGIS REST);
2. Spatial-join Census tract centroids with district polygons (within);
3. Save tract→district crosswalk (CSV) and print coverage/unmatched list.
"""

import pandas as pd
import geopandas as gpd
from shapely.geometry import Point

# Load district boundaries
url = "https://gisportal.boston.gov/arcgis/rest/services/PublicSafety/OpenData/MapServer/5/query?where=1=1&outFields=*&f=geojson"
districts = gpd.read_file(url).to_crs("EPSG:4326")

tracts = pd.read_csv("https://raw.githubusercontent.com/paddington-L831/Intro-to-Data-Analystics1/refs/heads/main/Census_Tracts_in_Boston.csv")
tracts_gdf = gpd.GeoDataFrame(
    tracts, geometry=[Point(xy) for xy in zip(tracts["intptlon20"], tracts["intptlat20"])],
    crs="EPSG:4326"
)

# Spatial join from centroid to district
crosswalk = gpd.sjoin(
    tracts_gdf[["geoid20", "geometry"]],
    districts[["DISTRICT", "geometry"]],
    how="left", predicate="within"
)[["geoid20", "DISTRICT"]].drop_duplicates().reset_index(drop=True)

# Save crosswalk
out_path = "/content/drive/MyDrive/tract_to_district.csv"
crosswalk.to_csv(out_path, index=False)

matched = crosswalk["DISTRICT"].notna().sum()
total = len(crosswalk)
print(f"[OK] Crosswalk created: {total} tracts")
print(f"[OK] Matched: {matched} ({matched/total*100:.1f}%)")

if matched < total:
    unmatched = crosswalk[crosswalk["DISTRICT"].isna()]["geoid20"].tolist()
    print(f"[INFO] Unmatched tracts: {len(unmatched)}")
    print(unmatched)

print(f"[Saved] tract_to_district → {out_path}")

"""**District-level SES Aggregation from Tracts**

We aggregate tract-level poverty & income to District level using the tract_to_district crosswalk, computing Poverty Rate and household-weighted median household income.
"""

# Import crosswalk
tract_to_district_file = "/content/drive/MyDrive/tract_to_district.csv"
tract_to_district = pd.read_csv(tract_to_district_file)

import pandas as pd

# Normalize keys
poverty_data["GEOID"] = poverty_data["GEO_ID"].astype(str).str.extract(r"(\d{11})")
income_data["GEOID"]  = income_data["GEO_ID"].astype(str).str.extract(r"(\d{11})")
tract_to_district["geoid20"] = tract_to_district["geoid20"].astype(str)

# Merge poverty & income into one SES table
ses = (
    poverty_data[["GEOID", "Total_Population", "Population_Below_Poverty"]]
    .merge(
        income_data[["GEOID", "Total_Households", "Median_Household_Income"]],
        on="GEOID",
        how="inner"
    )
)

# Attach district via crosswalk
ses_district = ses.merge(tract_to_district, left_on="GEOID", right_on="geoid20", how="inner")

# Aggregate sums at District level
district_ses = (
    ses_district.groupby("DISTRICT", as_index=False)
    .agg(
        pop_total=("Total_Population", "sum"),
        pop_poor=("Population_Below_Poverty", "sum"),
        hh_total=("Total_Households", "sum"),
        income_sum=("Median_Household_Income", "mean")
    )
)
district_ses["Poverty_Rate"] = district_ses["pop_poor"] / district_ses["pop_total"] * 100

# Weighted median-income approximation
income_weighted = (
    ses_district.assign(weighted_income=lambda d: d["Median_Household_Income"] * d["Total_Households"])
    .groupby("DISTRICT")
    .agg(
        weighted_income_sum=("weighted_income", "sum"),
        hh_total=("Total_Households", "sum")
    )
    .assign(Median_Household_Income_weighted=lambda d: d["weighted_income_sum"] / d["hh_total"])
    .reset_index()[["DISTRICT", "Median_Household_Income_weighted"]]
)

district_ses = (
    district_ses
    .drop(columns=["income_sum"])
    .merge(income_weighted, on="DISTRICT", how="left")
)

print(district_ses)

out_path = "/content/drive/MyDrive/district_ses.csv"
district_ses.to_csv(out_path, index=False)

district_ses.info()

"""### Summary
There is a brief summary of the steps we took of cleaning, transformation, and aggregation:

1. **Loading Data Sources**  
Crime incident and socioeconomic datasets were imported from Github.  
A geographic crosswalk file was created using GeoPandas for spatial joins.  

2. **Crime Data Cleaning**  
Converted the `OCCURRED_ON_DATE` column to proper datetime format, dropping invalid or missing entries.   
Removed records with missing or invalid district labels.  

3. **Socioeconomic Data Cleaning**  
Selected and renamed essential columns for clarity.  
Converted numeric fields to appropriate data types, ensuring consistency.  
Computed Poverty Rate as the percentage of population below the poverty line.  

4. **District Crosswalk and Merging**  
Mapped census tracts to police districts via spatial join and saved the crosswalk table.  
Normalized GEOID formats across poverty, income, and crosswalk data to allow merging.  

5. **District-Level Aggregation**  
Poverty and income measures were aggregated from tract-level to district-level.  
Population totals, household counts, and poverty counts were summed for each district.  
Median household income was computed using weighted average.


**So what:** now we get cleaned datasets, let's begin our analysis.

## V. Visualization & Analytsis

---
---

### Exploratory Data Analysis Summary

---

Summary of Our Team Assignment
"""

import geopandas as gpd
import matplotlib.pyplot as plt
import matplotlib.colors as mcolors

# === 1. 载入警区边界数据 ===
districts_url = "https://gisportal.boston.gov/arcgis/rest/services/PublicSafety/OpenData/MapServer/5/query?where=1=1&outFields=*&f=geojson"
districts = gpd.read_file(districts_url).to_crs("EPSG:4326")

# === 2. 警区编号 → 常用社区名称 映射字典 ===
district_name_map = {
    "A1":  "Downtown / Beacon Hill / Chinatown",
    "A7":  "East Boston",
    "A15": "Charlestown",
    "B2":  "Roxbury",
    "B3":  "Mattapan / Dorchester South",
    "C6":  "South Boston",
    "C11": "Dorchester North",
    "D4":  "South End / Back Bay / Fenway",
    "D14": "Allston / Brighton",
    "E5":  "West Roxbury / Roslindale",
    "E13": "Jamaica Plain",
    "E18": "Hyde Park / Readville"
}

# === 3. 准备用于绘图的 GeoDataFrame（带名称） ===
gdf = districts[['DISTRICT', 'geometry']].copy()
gdf['DISTRICT_NAME'] = gdf['DISTRICT'].map(district_name_map).fillna("")

# 如果 CRS 不一致，可以设置
if gdf.crs is None:
    gdf = gdf.set_crs("EPSG:4326")

# 为了更好的标注、自适应显示，将几何体投影到平面坐标系（如 EPSG:26986 或者本地投影）
gdf_plot = gdf.to_crs("EPSG:3857")  # Web Mercator 投影也可；或换成 26986
gdf_plot["rep_pt"] = gdf_plot.geometry.representative_point()

# === 4. 绘图 ===
fig, ax = plt.subplots(figsize=(10, 10))

# 自定义颜色：采用暗调黄系
cmap = plt.cm.YlOrBr
# 按索引映射，确保每区着色有差异
norm = mcolors.Normalize(vmin=0, vmax=len(gdf_plot) - 1)
gdf_plot.plot(
    ax=ax,
    column=gdf_plot.index,
    cmap=cmap,
    edgecolor="black",
    linewidth=1.0,
    alpha=0.8,
    norm=norm,
    legend=False
)

# 添加区号 + 名称标注
for _, row in gdf_plot.iterrows():
    x = row["rep_pt"].x
    y = row["rep_pt"].y
    code = row["DISTRICT"]
    name = row["DISTRICT_NAME"]
    txt = f"{code}\n{name}"
    ax.text(
        x, y, txt,
        ha="center", va="center",
        fontsize=9,
        fontweight="bold",
        color="black",
        bbox=dict(facecolor="white", edgecolor="none", alpha=0.7, pad=1)
    )

# 美化图像外观
ax.set_title("Boston Police Districts — Codes & Neighborhood Names", fontsize=16, fontweight="bold", pad=12)
ax.set_axis_off()
fig.patch.set_facecolor("#f9f5e0")  # 整体背景偏浅米黄色
ax.set_facecolor("#f5f3e0")

plt.tight_layout()
plt.show()

"""Our exploratory analysis investigated the relationship between socioeconomic conditions and crime patterns across Boston’s police districts. By combining crime incident reports with ACS income and poverty data, we identified that low-income and high-poverty areas experience disproportionately higher crime rates. High-income districts were dominated by property and administrative offenses, while violent crimes were more common in disadvantaged areas. Spatial and temporal analyses revealed overlapping hotspots of poverty and crime, and a higher share of night-time incidents in central districts. These findings provide a data-driven foundation for understanding how socioeconomic disparities influence urban safety and inform further analysis on temporal and income-based patterns.

### 1. Establishing Correlations, Demonstrating Economic Conditions' Impact on Crime Rates

---

#### 1.1 Do low-income communities experience higher crime rates?

This analysis aggregates crime incidents by district and merges them with socioeconomic data to identify low-income areas. Districts below the citywide median income are flagged, and the top eight by crime volume are visualized in a donut chart. Low-income districts are highlighted with hatching and black outlines to emphasize disparities in crime distribution.
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

# Set top-N districts
TOP_N = 8

# Aggregate crimes by district
if 'crime_incident' not in globals() or crime_incident.empty:
    raise ValueError("`crime_incident` is empty or not defined.")

shooting_map = {'1': 1, 'Y': 1, 'YES': 1, 'TRUE': 1, 'T': 1}
shooting_num = (
    crime_incident.get('SHOOTING')
    .astype(str).str.strip().str.upper()
    .map(shooting_map).fillna(0).astype(int)
)

district_crime = (
    crime_incident.assign(SHOOTING_NUM=shooting_num)
    .groupby('DISTRICT', as_index=False)
    .agg(total_crimes=('INCIDENT_NUMBER', 'count'),
         shootings=('SHOOTING_NUM', 'sum'))
    .sort_values('total_crimes', ascending=False, ignore_index=True)
)

# Low-income flag source based on SES table
if 'district_ses' not in globals() or district_ses.empty:
    raise ValueError("`district_ses` is empty or not defined. It must include DISTRICT and Median_Household_Income_weighted.")

required_cols = {'DISTRICT', 'Median_Household_Income_weighted'}
missing = required_cols - set(district_ses.columns)
if missing:
    raise ValueError(f"`district_ses` is missing columns: {missing}")

ses_income = district_ses[['DISTRICT', 'Median_Household_Income_weighted']].copy()

# Set threshold: citywide median of weighted household income
income_threshold = ses_income['Median_Household_Income_weighted'].median()

# flag low-income
ses_income['Low_Income_Flag'] = ses_income['Median_Household_Income_weighted'] < income_threshold

# merge flag into crime table
district_crime = district_crime.merge(ses_income[['DISTRICT', 'Low_Income_Flag']], on='DISTRICT', how='left')

# Top-N & merge others
top = district_crime.head(TOP_N).copy()

# Merge the rest into 'Other'
others_total = district_crime['total_crimes'].iloc[TOP_N:].sum()
if others_total > 0:
    top.loc[len(top)] = ['Other', others_total, 0, np.nan]

# Plot prep
values = top['total_crimes'].to_numpy()
labels = top['DISTRICT'].astype(str).to_numpy()
total = int(values.sum())
explode = [0.06 if i < min(3, len(values)) else 0 for i in range(len(values))]

# keep distinct colors
base_colors = sns.color_palette("Set3", n_colors=len(values))

def autopct_fmt(pct):
    # percentage + absolute count
    return f"{pct:.1f}%\n({int(round(pct/100*total)):,})"

# Donut: low-income wedges hatched and outlined
sns.set_theme(style="whitegrid")
fig, ax = plt.subplots(figsize=(9.2, 9.2))

wedges, texts, autotexts = ax.pie(
    values,
    colors=base_colors,
    labels=None,
    autopct=autopct_fmt,
    startangle=90,
    counterclock=False,
    explode=explode,
    pctdistance=0.78,
    wedgeprops=dict(width=0.38)
)

# Apply hatch & edge to low-income wedges
for i, w in enumerate(wedges):
    flag = top.iloc[i]['Low_Income_Flag']
    if flag == True:
        w.set_hatch('///')
        w.set_edgecolor('black')
        w.set_linewidth(1.2)

# center text
ax.text(0, 0, f"Total\n{total:,}", ha='center', va='center', fontsize=12, fontweight='bold')

# Legend with low-income label
legend_labels = []
for i, lab in enumerate(labels):
    flag = top.iloc[i]['Low_Income_Flag']
    if pd.isna(flag):
        legend_labels.append(f"{lab} (Other/Mixed)")
    elif flag:
        legend_labels.append(f"{lab}  • Low-income")
    else:
        legend_labels.append(lab)

ax.legend(wedges, legend_labels, title="District", loc="center left",
          bbox_to_anchor=(1.02, 0.5), frameon=False)

# title & threshold note
ax.set_title("Share of Total Crimes by District\nLow-income districts hatched; threshold = citywide median income",
             fontsize=14, fontweight='bold', pad=14)
# display numeric threshold
plt.figtext(0.5, 0.02, f"Low-income threshold (median income): ${income_threshold:,.0f}",
            ha='center', fontsize=11)

plt.tight_layout()
plt.show()

"""Answer: Low-income districts such as B2, D4, and C11 account for a disproportionately high share of crime—together exceeding half of all incidents citywide. These results suggest a strong correlation between lower household income and higher crime incidence, indicating that socioeconomic disadvantage is a significant factor in crime concentration.

#### 1.2 How does socioeconomic status correlate with overall crime rate?

This analysis tests how strongly poverty and income levels relate to crime rates across Boston's districts. After merging socioeconomic data with crime totals, crime rates per 10,000 residents are computed and examined through scatterplots, correlation analysis, and an OLS regression to quantify the strength and direction of these relationships.
"""

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import statsmodels.api as sm

# Aggregate crimes by district
crime_by_district = (
    crime_incident
    .groupby('DISTRICT', as_index=False)
    .agg(total_cases=('INCIDENT_NUMBER', 'count'))
)

# Merge with SES data, include: DISTRICT, pop_total, Poverty_Rate, Median_Household_Income_weighted
merged = pd.merge(
    crime_by_district,
    district_ses,
    on='DISTRICT',
    how='left'
)

# Compute crime rate per 10k population
merged['crime_rate_per10k'] = merged['total_cases'] / merged['pop_total'] * 10000

# Plots: Scatter with OLS fit lines
sns.set_theme(style='whitegrid')
fig, axes = plt.subplots(1, 2, figsize=(14, 6))

# Poverty vs Crime rate
sns.regplot(
    data=merged, x='Poverty_Rate', y='crime_rate_per10k',
    scatter_kws={'s': 60, 'alpha': 0.8},
    line_kws={'color': 'red'},
    ax=axes[0]
)
axes[0].set_title('Crime Rate vs Poverty Rate', fontsize=14, fontweight='bold')
axes[0].set_xlabel('Poverty Rate (%)')
axes[0].set_ylabel('Crime Rate (per 10k people)')

# Income vs Crime rate
sns.regplot(
    data=merged, x='Median_Household_Income_weighted', y='crime_rate_per10k',
    scatter_kws={'s': 60, 'alpha': 0.8},
    line_kws={'color': 'red'},
    ax=axes[1]
)
axes[1].set_title('Crime Rate vs Median Household Income', fontsize=14, fontweight='bold')
axes[1].set_xlabel('Median Household Income ($)')
axes[1].set_ylabel('Crime Rate (per 10k people)')

plt.tight_layout()
plt.show()

# Correlation matrix of Crime rate, Poverty, Income
corr_matrix = merged[['crime_rate_per10k', 'Poverty_Rate', 'Median_Household_Income_weighted']].corr()
print("\nCorrelation Matrix:")
print(corr_matrix)

# OLS regression: crime_rate_per10k ~ Poverty_Rate + Median_Household_Income_weighted
# Drop rows with missing values before fitting
X = merged[['Poverty_Rate', 'Median_Household_Income_weighted']]
y = merged['crime_rate_per10k']
data = pd.concat([X, y], axis=1).dropna()

X_clean = sm.add_constant(data[['Poverty_Rate', 'Median_Household_Income_weighted']])
y_clean = data['crime_rate_per10k']

model = sm.OLS(y_clean, X_clean).fit()
print("\nRegression Summary:")
print(model.summary())

"""Answer: The analysis shows a moderate positive association between poverty and crime rates, and a weaker negative association between income and crime rates across Boston districts. The correlation matrix indicates that poverty rate correlates with crime rate at r = 0.49, while median household income correlates negatively with crime rate at r = –0.16. Scatter plots confirm these trends: districts with higher poverty rates generally experience higher crime rates, whereas wealthier districts tend to have lower rates.

The OLS regression results provide further evidence. Poverty rate has a positive coefficient (β = 51.1, SE = 24.4, p = 0.066), while median household income shows a negative coefficient (β = –0.006, SE = 0.006, p = 0.267), but it is not statistically significant at conventional levels. The overall model explains 34.5% of the variance with R² = 0.345, indicating moderate explanatory power. The findings align with expectations that economically disadvantaged communities bear a higher burden of crime.

#### 1.3 Summary

This theme explores how socioeconomic conditions shape crime patterns across Boston’s police districts. The analysis begins by comparing crime volumes between high- and low-income communities. Visualizing district-level crime shares through a donut chart reveals that low-income districts such as B2 (Roxbury), D4 (South End), and C11 (Dorchester) collectively account for over half of all reported crimes citywide. These results demonstrate that economic disadvantage is strongly linked to higher crime concentration, suggesting that limited resources, population density, and socioeconomic stressors amplify exposure to criminal activity.

To further quantify this relationship, a regression-based analysis examines how poverty rate and median household income correlate with crime rates per 10,000 residents. The findings indicate a moderate positive relationship between poverty and crime and a weaker negative association between income and crime. Specifically, districts with higher poverty rates consistently experience elevated crime levels, while wealthier districts tend to have fewer incidents. Although the regression results show moderate explanatory power (R² ≈ 0.35), they confirm that economic hardship remains one of the most influential predictors of district-level crime rates.

Overall, the analyses in this theme provide clear empirical evidence that socioeconomic inequality significantly contributes to variations in urban crime, emphasizing the need for targeted policy interventions and community-based initiatives in economically vulnerable neighborhoods.

### 2. Crime Composition, Revealing the Composition of Crime Issues Across Census Tracts

---

#### 2.1 Crime Types by District.

This code classifies Boston crime incidents into seven major categories using regular expressions and compares their distribution across police districts. It cleans the offense descriptions, assigns each record a crime type, and calculates both citywide and district-level percentages. The results are visualized as a horizontal stacked bar chart, showing how different crime types vary by district.
"""

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import matplotlib.ticker as mtick
import re

# Basic cleaning
df = (crime_incident[['DISTRICT','OFFENSE_DESCRIPTION']]
      .dropna(subset=['DISTRICT','OFFENSE_DESCRIPTION'])
      .assign(OFFENSE_DESCRIPTION=lambda x: x['OFFENSE_DESCRIPTION'].astype(str).str.lower().str.strip()))

# Regex rules
patterns = {
    'Violent': re.compile(r'(homicide|murder|rape|sexual\s*assault|robbery|aggravated\s*assault|assault\s*w/|abdw|a&b\s*dangerous\s*weapon|shoot|gun|weapon)'),
    'Property': re.compile(r'(burglary|break(?:-| )?and(?:-| )?enter|b&e|larceny|theft|stolen|motor\s*vehicle|auto\s*theft|arson|shoplift|vandal(?:ism)?|property\s*damage|fraud|forgery|counterfeit)'),
    'Drug': re.compile(r'(drug|narcotic|controlled\s*substance|sick\s*assist\s*-\s*drug)'),
    'Traffic': re.compile(r'(m/v|motor\s*vehicle|auto|accident|leaving\s*scene|hit\s*&?\s*run|operating\s*after\s*rev|violation\s*of\s*auto\s*law)'),
    'Public Order': re.compile(r'(verbal\s*dispute|threats?\s*to\s*do\s*bodily\s*harm|harassment|trespass|disorderly|disturbing\s*the\s*peace)'),
    'Medical-Assist': re.compile(r'(sick\s*assist|sick/injured/medical|sudden\s*death|death\s*investigation|missing\s*person)'),
    'Administrative': re.compile(r'(investigate\s*person|investigate\s*property|property\s*-\s*(lost|missing|found)|service\s*to\s*other\s*agency|fire\s*report|landlord\s*-\s*tenant|license\s*premise|warrant\s*arrest)')
}
order_cats = ['Violent','Property','Drug','Traffic','Public Order','Medical-Assist','Administrative']

def classify(text: str) -> str:
    for cat in order_cats:
        if patterns[cat].search(text):
            return cat
    return 'Other'

df['crime_type'] = df['OFFENSE_DESCRIPTION'].apply(classify)

# Citywide shares
city_counts = df['crime_type'].value_counts().reindex(order_cats + ['Other'], fill_value=0)
city_share  = (city_counts / city_counts.sum() * 100).round(1)
print("Citywide shares (%):\n", city_share.to_string())

# compute district shares
plot_cats = order_cats + ['Other']
by_dist = (df.groupby(['DISTRICT','crime_type'])
             .size().unstack(fill_value=0)
             .reindex(columns=plot_cats, fill_value=0))
by_dist = by_dist.loc[by_dist.sum(axis=1) > 0]
by_dist_pct = by_dist.div(by_dist.sum(axis=1), axis=0) * 100

# Sort by Violent in descending order
sort_key = 'Violent' if 'Violent' in by_dist_pct.columns else by_dist_pct.sum(axis=1).index[0]
order = by_dist_pct[sort_key].sort_values(ascending=False).index
by_dist_pct = by_dist_pct.loc[order]

# Plot (horizontal stacked bars)
sns.set_theme(style='whitegrid')
fig, ax = plt.subplots(figsize=(12, max(6, 0.5*len(by_dist_pct))))

palette = ['#d62728', '#1f77b4', '#2ca02c', '#9467bd', '#ff7f0e', '#17becf', '#7f7f7f', '#bcbd22']
by_dist_pct[plot_cats].plot(kind='barh', stacked=True, ax=ax, width=0.9, color=palette)

ax.set_title('Distribution of Crime Types by District', fontsize=15, fontweight='bold', pad=10)
ax.set_xlabel('Share of Crimes (%)'); ax.set_ylabel('District')
ax.xaxis.set_major_formatter(mtick.PercentFormatter())

# In-bar labels for segments >6%
for i, (_, row) in enumerate(by_dist_pct.iterrows()):
    cum = 0.0
    for val in row[plot_cats]:
        if val > 6:
            ax.text(cum + val/2, i, f"{val:.0f}%", va='center', ha='center',
                    color='white', fontsize=9, fontweight='bold')
        cum += val

# Footnote with citywide Other share
plt.figtext(0.5, 0.01, f'Citywide "Other" share: {city_share["Other"]:.1f}%  — consider expanding rules if too high',
            ha='center', fontsize=10)

sns.despine(left=True, bottom=False)
plt.tight_layout()
plt.show()

"""Answer:

Citywide, Boston's crime composition is dominated by Property and Administrative offenses, while Violent crimes make up only about 1.7% of all incidents. District-level variation is evident: D14 and A15 report the highest property-crime shares (over 40%), whereas E13 and E5 show more Medical-Assist cases. B2 and B3 stand out for a higher proportion of Administrative incidents. These differences suggest distinct community patterns, where residential areas face more property issues and inner-city districts experience greater administrative and service-related burdens.

#### 2.2 Distribution of violent and property crimes across regions with differing economic conditions.

Boston neighborhoods were categorized into four income brackets based on median household income (low-income, lower-middle-income, upper-middle-income, high-income), and the distribution of violent crimes versus property crimes was compared across these categories.
"""

crosswalk_clean = crosswalk.copy()
income_clean    = income.copy()
crime_clean     = crime_incident.copy()

# Harmonize keys
crosswalk_clean['geoid20'] = crosswalk_clean['geoid20'].astype(str).str.extract(r'(\d{11,12})')

geo_col = [c for c in income_clean.columns if 'geo' in c.lower()][0]
income_clean['geo_id_clean'] = income_clean[geo_col].astype(str).str.extract(r'(\d{11,12})')

income_clean = income_clean.rename(columns={'S1901_C01_012E': 'Median_Income'})
income_clean['Median_Income'] = pd.to_numeric(income_clean['Median_Income'], errors='coerce')

# Map tract to district, then aggregate to one row per DISTRICT
tracts_with_income = crosswalk_clean.merge(
    income_clean[['geo_id_clean','Median_Income']],
    left_on='geoid20', right_on='geo_id_clean', how='left'
)

# drop missing tract incomes
tracts_with_income = tracts_with_income.dropna(subset=['Median_Income'])

# Choose aggregation: median across tracts in the district (simple and robust)
district_income = (
    tracts_with_income
    .groupby('DISTRICT', observed=False)['Median_Income']
    .median()
    .reset_index(name='District_Median_Income')
)

# Attach one income value per district to each crime
crime_income = crime_clean.merge(district_income, on='DISTRICT', how='left')

# Sanity check: no duplication
assert len(crime_income) == len(crime_clean), "Merge exploded rows — check keys!"

# Create income quartiles from district-level income
crime_income = crime_income.dropna(subset=['District_Median_Income']).copy()
crime_income['Income_Level'] = pd.qcut(
    crime_income['District_Median_Income'],
    q=4,
    labels=['Low Income', 'Lower-Mid', 'Upper-Mid', 'High Income']
)

# Keep a working copy
tmp = crime_income.copy()

print("crimes:", len(crime_clean),
      "| after merge:", len(crime_income),
      "| districts with income:", district_income['DISTRICT'].nunique())

import matplotlib.pyplot as plt
import seaborn as sns

# Map raw offense text to a simplified category
def broad_crime_type(desc: str) -> str:
    t = str(desc).upper()
    if any(k in t for k in ['ASSAULT','BATTERY','HOMICIDE','MURDER','ROBBERY','SEX']):
        return 'Violent'
    if any(k in t for k in ['BURGLARY','BREAK','LARCENY','THEFT','STOLEN']):
        return 'Property'
    return 'Other'

# Copy source and create the simplified crime type
tmp_vp = tmp.copy()
tmp_vp['Crime_Type'] = tmp_vp['OFFENSE_DESCRIPTION'].apply(broad_crime_type)
tmp_vp = tmp_vp[tmp_vp['Crime_Type'].isin(['Violent','Property'])].copy()

# Count incidents by income level and crime type
summary_vp = (
    tmp_vp.groupby(['Income_Level','Crime_Type'], observed=False)
    .size()
    .reset_index(name='Count')
)

# Plot grouped bars: crime volume across income quartiles
plt.figure(figsize=(8,5))
sns.barplot(
    data=summary_vp,
    x='Income_Level', y='Count', hue='Crime_Type',
    palette=['#e76f51','#264653']
)
plt.title('Violent vs Property Crimes Across Income Levels', fontsize=13, fontweight='bold')
plt.xlabel('Income Level (quartiles by district median income)')
plt.ylabel('Crime Count')
plt.legend(title='Crime Type')
plt.tight_layout()
plt.show()

"""Answer:

Crime rates generally show a negative correlation with income levels: low-income areas experience the highest rates of both violent and property crimes, with property crimes consistently outnumbering violent crimes. As income increases, both types of crime decrease overall.

#### 2.3 Are shootings concentrated in specific districts?

This analysis examines whether shootings are disproportionately concentrated in specific Boston police districts. A binary shooting flag is standardized from the original data, and crime incidents are aggregated by district to count total cases and shootings. The shooting share (%) is then calculated for each district, producing a chart that highlights areas with the highest concentration of shooting incidents.
"""

import pandas as pd

# Construct binary flag for shootings
shooting_map = {'1': 1, 'Y': 1, 'YES': 1, 'TRUE': 1, 'T': 1}
crime_incident['SHOOTING_FLAG'] = (
    crime_incident.get('SHOOTING')
    .astype(str).str.strip().str.upper()
    .map(shooting_map).fillna(0).astype(int)
)

# Aggregate by district
shooting_stats = (
    crime_incident
    .groupby('DISTRICT', as_index=False)
    .agg(
        total_cases=('INCIDENT_NUMBER', 'count'),
        shootings=('SHOOTING_FLAG', 'sum')
    )
)

# Compute shooting share
shooting_stats['shooting_share_%'] = (
    shooting_stats['shootings'] / shooting_stats['total_cases'] * 100
).round(2)

# Sort by shootings
shooting_stats = shooting_stats.sort_values('shootings', ascending=False).reset_index(drop=True)

print("Shooting Incidents by District:")

plt.figure(figsize=(12, 6))
sns.barplot(data=district_crime.sort_values('shootings', ascending=False), x='DISTRICT', y='shootings')
plt.title('Shooting Incidents by District')
plt.xlabel('District')
plt.ylabel('Number of Shootings')
plt.savefig("shootings_by_district.png")
plt.show()

"""Answer:

The data indicate that shootings are unevenly distributed across Boston police districts, with certain areas experiencing higher concentrations. District B3 reported the largest absolute number of shootings, accounting for 2.52% of all its crime incidents. District B2 followed with 171 shootings, while C11 recorded 140 shootings. Together, these three districts account for nearly half of all shootings in the dataset, highlighting clear geographic clustering.

At the other end of the distribution, districts such as A1 and D14 had comparatively low firearm-related activity both in raw counts and in proportional terms.

The result suggests that firearm violence is concentrated in specific districts, which may warrant targeted prevention and enforcement strategies.

#### 2.4 What crime types correspond to the economic conditions of all regions? (All regions & all crime types)?

This analysis visualizes how poverty levels and dominant crime types vary across Boston police districts. District boundaries are loaded from geospatial data and combined with socioeconomic indicators (poverty rates) from the SES dataset. Crime incidents are grouped by district and offense type, identifying the top two most frequent offenses per district along with their percentage shares. The results are merged and displayed on a choropleth map, where each district's color represents its poverty rate, and text labels indicate its most common offenses. This visualization highlights spatial patterns linking economic conditions with local crime composition.
"""

import pandas as pd
import numpy as np
import geopandas as gpd
import matplotlib.pyplot as plt
import matplotlib.patheffects as pe
from textwrap import fill

TOP_K = 2

def wrap(s, width=26, max_lines=2):
    s = "" if pd.isna(s) else str(s).strip()
    t = fill(s, width=width, break_long_words=False)
    lines = t.splitlines()
    if len(lines) > max_lines:
        lines = lines[:max_lines]
        if not lines[-1].endswith("..."):
            lines[-1] = (lines[-1] + " ...")[:width+3]
    return "\n".join(lines)

# Boundaries and representative points
gdf = districts[['DISTRICT', 'geometry']].copy()
if gdf.crs is None: gdf = gdf.set_crs(4326)
gdf = gdf.to_crs(26986)
gdf['rep_pt'] = gdf.representative_point()

# SES
ses = district_ses[['DISTRICT', 'Poverty_Rate']].drop_duplicates().copy()
ses['Poverty_Rate'] = pd.to_numeric(ses['Poverty_Rate'], errors='coerce')

# Top-K offense types for each district
ci = crime_incident[['DISTRICT', 'OFFENSE_DESCRIPTION']].dropna().copy()
ci['OFFENSE_DESCRIPTION'] = ci['OFFENSE_DESCRIPTION'].astype(str).str.strip()

cts = (ci.groupby(['DISTRICT', 'OFFENSE_DESCRIPTION']).size()
         .reset_index(name='n'))
tot = cts.groupby('DISTRICT', as_index=False)['n'].sum().rename(columns={'n':'N_dist'})
cts = cts.merge(tot, on='DISTRICT', how='left')
cts['share'] = cts['n'] / cts['N_dist'] * 100

topk = (cts.sort_values(['DISTRICT','n'], ascending=[True, False])
            .groupby('DISTRICT').head(TOP_K))

labels = (topk.assign(lbl=lambda r: r['OFFENSE_DESCRIPTION'] + " (" + r['share'].round(0).astype(int).astype(str) + "%)")
               .groupby('DISTRICT')['lbl']
               .apply(lambda s: "\n".join([wrap(x, 26, 1) for x in s.tolist()]))
               .reset_index()
               .rename(columns={'lbl':'TopLabel'}))

# Merge datasets and plot
m = (gdf.merge(ses, on='DISTRICT', how='left')
        .merge(labels, on='DISTRICT', how='left'))
m['TopLabel'] = m['TopLabel'].fillna('(no data)')

fig, ax = plt.subplots(figsize=(12, 12))
cmap = plt.cm.OrRd
vmin, vmax = np.nanmin(m['Poverty_Rate'].values), np.nanmax(m['Poverty_Rate'].values)

m.plot(ax=ax, column='Poverty_Rate', cmap=cmap, linewidth=1.0, edgecolor='#444444')
sm = plt.cm.ScalarMappable(norm=plt.Normalize(vmin=vmin, vmax=vmax), cmap=cmap)
cbar = fig.colorbar(sm, ax=ax, fraction=0.035, pad=0.02)
cbar.ax.set_ylabel('Poverty Rate (%)', rotation=90)

for _, row in m.iterrows():
    x, y = row['rep_pt'].x, row['rep_pt'].y
    ax.text(
        x, y, f"{row['DISTRICT']}\n{row['TopLabel']}",
        ha='center', va='center',
        fontsize=8, color='#111', weight='bold',
        path_effects=[pe.withStroke(linewidth=3, foreground='white')],
        zorder=10
    )

ax.set_title("Boston Police Districts — Poverty & Top Offense Type", fontsize=15, pad=12)
ax.set_xticks([]); ax.set_yticks([]); ax.set_aspect('equal')
for s in ['top','right','left','bottom']: ax.spines[s].set_visible(False)

plt.tight_layout()
plt.savefig("district_map_poverty_with_top_offense_MIN.png", dpi=300)
plt.show()

"""Answer: In Boston's high-income districts, crimes are largely non-violent, with property offenses making up about 30%, followed by administrative and medical-assist incidents. Violent and drug-related crimes together account for less than 5% of total reports, indicating that wealthier areas experience fewer serious offenses and more service or property-related incidents.

#### 2.5 What crime types are prevalent in the three highest-crime areas?

This analysis aims to identify the three areas with the highest crime rates in Boston and investigate the predominant crime types within these areas. First, the crime rate per 10,000 residents is calculated by comparing total crime counts with population data for each area, thereby determining the top three areas by crime rate. Subsequently, for these three areas, the most frequent crime types are statistically analyzed and visually compared.
"""

# Calculate total crimes for each district
district_crime = (
    crime_incident
    .groupby('DISTRICT', as_index=False)
    .agg(total_crimes=('INCIDENT_NUMBER', 'count'))
)

# Merge with population data to compute crime rate
district_crime = (
    district_crime
    .merge(district_ses[['DISTRICT', 'pop_total']], on='DISTRICT', how='left')
    .assign(crime_rate_per_10k=lambda d: d['total_crimes'] / d['pop_total'] * 10000)
    .sort_values('crime_rate_per_10k', ascending=False, ignore_index=True)
)

# Select the top three districts with the highest crime rates
top3_districts = district_crime.head(3)['DISTRICT'].tolist()
print("The three districts with the highest crime rates:", top3_districts)

# Filter crime records from the top 3 districts
top3_crimes = crime_incident[crime_incident['DISTRICT'].isin(top3_districts)]

# Count the number of offenses by district and offense description
crime_type_counts = (
    top3_crimes
    .groupby(['DISTRICT', 'OFFENSE_DESCRIPTION'], as_index=False)
    .size()
    .rename(columns={'size': 'count'})
)

# Get the top 5 most frequent crime types in each district (adjustable)
top5_each = (
    crime_type_counts
    .sort_values(['DISTRICT', 'count'], ascending=[True, False])
    .groupby('DISTRICT')
    .head(5)
)

# Visualization
import seaborn as sns
import matplotlib.pyplot as plt

# Create a grouped bar chart showing the top 5 crime types by district
plt.figure(figsize=(10, 6))
sns.barplot(
    data=top5_each,
    x='count',
    y='OFFENSE_DESCRIPTION',
    hue='DISTRICT',
    palette=sns.color_palette("Blues", n_colors=3),
    edgecolor='black',
    alpha=0.9
)

plt.title('Top 5 Crime Types in the Three Highest-Crime-Rate Districts', fontsize=14, fontweight='bold', pad=10)
plt.xlabel('Number of Cases', fontsize=12)
plt.ylabel('Offense Description', fontsize=12)
plt.legend(title='District', fontsize=10, title_fontsize=11, loc='best', frameon=True)
sns.despine(left=True, bottom=True)
plt.tight_layout()
plt.show()

"""Answer:

The choropleth map reveals a clear spatial link between poverty and crime composition across Boston. Districts with higher poverty rates, such as B2 (Roxbury) and D4 (South End), record the highest shares of “Investigate Person” and “Sick Assist” incidents—indicating more frequent police interventions and public-service calls. By contrast, lower-poverty districts like A15 (Charlestown) and A7 (East Boston) exhibit similar offense patterns but at smaller proportions, reflecting less concentrated demand for emergency or investigation-related responses. Overall, the findings suggest that social and economic disadvantage correlates with heavier reliance on law enforcement and medical services, underscoring how poverty influences both the volume and nature of reported incidents.

#### 2.6 Reverse-engineer economic conditions corresponding to all crime types.

This analysis aims to infer corresponding socioeconomic conditions from the spatial distribution patterns of crime types. The specific methodology involves: first identifying the dominant areas within Boston's districts where each crime type occurs most frequently; then correlating these crime types with socioeconomic indicators (such as poverty rates) in their dominant areas. This establishes a correspondence between crime patterns and socioeconomic contexts, revealing the socioeconomic conditions that foster specific types of crime.
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from textwrap import fill

def find_col(df, cands):
    low = {c.lower(): c for c in df.columns}
    for c in cands:
        if c.lower() in low:
            return low[c.lower()]
    return None

# from crime_incident
col_dist = find_col(crime_incident, ['DISTRICT','district'])
col_off  = find_col(crime_incident, ['OFFENSE_DESCRIPTION','Offense Description','OFFENSE','OFFENSE_CODE_GROUP'])

# from district_ses
ses_key  = find_col(district_ses, ['DISTRICT','district'])
col_pov  = find_col(district_ses, ['Poverty_Rate','poverty_rate','Percent_Below_Poverty'])


# Find highest-frequency district for each offense type
ci = crime_incident[[col_dist, col_off]].dropna().copy()
counts = ci.groupby([col_off, col_dist]).size().reset_index(name='n')

# For each crime type, select the district with max count
top_district = counts.loc[counts.groupby(col_off)['n'].idxmax()].reset_index(drop=True)

# compute total citywide count per offense type
total_by_type = counts.groupby(col_off, as_index=False)['n'].sum().rename(columns={'n':'n_total'})

# Merge poverty data (SES)
ses = district_ses[[ses_key, col_pov]].drop_duplicates()
dom = (top_district.merge(ses, left_on=col_dist, right_on=ses_key, how='left')
                  .merge(total_by_type, on=col_off, how='left'))

# Compute citywide median poverty rate and define grouping
metric_col = col_pov
city_median = ses[metric_col].median()
dom['Wealth_Group'] = np.where(dom[metric_col] >= city_median, 'Poor District', 'Rich District')
x_label = "Poverty Rate (%) of dominant district"

# Keep top N common crime types and prepare for plotting
TOP_N = 15
plot_df = (dom.sort_values('n_total', ascending=False)
              .head(TOP_N)
              .sort_values(metric_col, ascending=True)
              .reset_index(drop=True))

# Auto-wrap offense labels + append dominant district name
y_labels = [f"{fill(t, 32)}\n[{d}]" for t, d in zip(plot_df[col_off], plot_df[col_dist])]

fig_h = max(9, 0.65 * len(plot_df))
plt.figure(figsize=(11.5, fig_h))

# Plot horizontal bars
plt.barh(y_labels, plot_df[metric_col], color="#5fa3c7")

# Add median line
plt.axvline(city_median, linestyle='--', linewidth=1, color='black')

# Add text labels for each bar (poverty rate %)
for y, v in enumerate(plot_df[metric_col].values):
    if pd.isna(v):
        continue
    txt = f"{v:.1f}%"
    x_pos = v + (plot_df[metric_col].max() - plot_df[metric_col].min()) * 0.02
    plt.text(x_pos, y, txt, va='center')

# Labels and title
plt.xlabel(x_label)
plt.ylabel("Crime Type (dominant district in brackets)")
plt.title(f"Economic condition (poverty rate) of dominant districts by crime type\n"
          f"(Top {TOP_N} crime types; dashed line = city median poverty rate)")

plt.tight_layout()
plt.show()

"""Answer: Most dominant crime types are concentrated in districts with above-median poverty levels. For example, offenses such as assault, vandalism, and property damage are primarily concentrated in District B2, where the poverty rate reaches 29.7%, nearly double the citywide median. In contrast, minor theft and traffic-related offenses cluster in wealthier districts such as C11 and A1, indicating a clear socioeconomic divide in crime patterns.

#### 2.7 Summary

The analyses recognize unique socioeconomic patterns of Boston crime. Citywide, property and administrative crimes dominate, with violent offenses being a minority. The incidence of these types of offenses varies extensively across precincts—more affluent communities experience more numbers of property and service-type offenses, whereas poor neighborhoods observe higher rates of violent and drug offenses.

With rising levels of income, violent and property crime declines, indicating a negative association between socioeconomic status and prevalence of crime. Firearm violence is comparatively concentrated in a few of the districts, B2, B3, and C11, suggesting localized clustering of gun violence that could necessitate local prevention strategies.

High-income precincts have mostly non-violent crimes of theft and administrative crimes, whereas the three most crime-prone precincts possess special profiles: A1 for drug and public nuisance offenses, B2 for property crimes, and D4 for theft and vandalism. Also, in correlating socioeconomic determinants with types of crime, precincts with higher poverty levels such as B2 are victimized by severe offenses of assault and vandalism while wealthier precincts suffer from petty larceny or traffic offenses.

Together, these findings show that socioeconomic inequality strongly impacts Boston's crime profile—poorer neighborhoods are subjected to more violent crime, and wealthier neighborhoods experience a narrower palette of low-severity offenses. This emphasizes the need for targeted, context-sensitive policy interventions to address the underlying socioeconomic disparities that fuel metropolitan crime profiles.

### 3. Crime spacing, exploring the Distribution of Crime Density and Socioeconomic Conditions Across Different Areas of Boston

---

#### 3.1 Geographic Crime Hotspots: Mapping Crime Density and Socioeconomic Inequality

This analysis maps Boston's geographic crime hotspots and links them to socioeconomic conditions. Crime incidents are visualized with a Folium heatmap, while census tract data on poverty and income are spatially joined and aggregated to police districts, producing choropleth maps that highlight spatial disparities across the city.
"""

pip install folium

#We first create a heatmap of the spatial distribution of criminal incidents.

import folium
from folium.plugins import HeatMap

# Extract coordinates
heat_data = crime_incident[["Lat", "Long"]].dropna().values.tolist()

# Initialize map centered at Boston
m = folium.Map(location=[42.3601, -71.0589], zoom_start=12)

# Add heatmap layer
HeatMap(heat_data, radius=12, min_opacity=0.3, blur=18).add_to(m)

m

import geopandas as gpd
import pandas as pd
import matplotlib.pyplot as plt

# Read MA statewide tracts and keep Suffolk County only
tracts = gpd.read_file("https://www2.census.gov/geo/tiger/TIGER2020/TRACT/tl_2020_25_tract.zip")
tracts = tracts[tracts['COUNTYFP'] == '025'].copy()

# Attach ACS metrics to tract polygons by GEOID
tracts['GEOID'] = tracts['GEOID'].astype(str)
tracts = tracts.merge(
    poverty_data[['GEOID','Total_Population','Population_Below_Poverty','Poverty_Rate']],
    on='GEOID', how='left'
).merge(
    income_data[['GEOID','Total_Households','Median_Household_Income']],
    on='GEOID', how='left'
)

# Project to EPSG:26986 before computing centroids
projected_crs = "EPSG:26986"
districts_proj = districts.to_crs(projected_crs)
tracts_proj    = tracts.to_crs(projected_crs)

# assign tract to a police district
tracts_pts = tracts_proj.copy()
tracts_pts['geometry'] = tracts_pts.geometry.centroid
tracts_joined = gpd.sjoin(
    tracts_pts, districts_proj[['DISTRICT','geometry']],
    how='left', predicate='within'
)

# Aggregate to district: population-weighted poverty rate, hh-weighted median income
def agg_to_district(g):
    pop_total = g['Total_Population'].sum(min_count=1)
    pop_poor  = g['Population_Below_Poverty'].sum(min_count=1)
    hh_total  = g['Total_Households'].sum(min_count=1)
    inc_num   = (g['Median_Household_Income'] * g['Total_Households']).sum(min_count=1)
    return pd.Series({
        'Poverty_Rate_District': (pop_poor / pop_total * 100) if pop_total else None,
        'Median_HH_Income_w': (inc_num / hh_total) if hh_total else None
    })

agg = tracts_joined.groupby('DISTRICT', as_index=False).apply(agg_to_district).reset_index(drop=True)

# Join metrics back to district polygons for mapping
district_map = districts_proj.merge(agg, on='DISTRICT', how='left')

# Plot side-by-side choropleths: poverty rate & household income
fig, axes = plt.subplots(1, 2, figsize=(16, 8))

district_map.plot(
    column='Poverty_Rate_District', cmap='Reds',
    linewidth=0.6, edgecolor='gray', legend=True,
    legend_kwds={'label': "Poverty Rate (%)"},
    ax=axes[0]
)
axes[0].set_title("Geographic Hotspot of Poverty Rate (by Police District)", fontsize=14, fontweight='bold')
axes[0].axis('off')

district_map.plot(
    column='Median_HH_Income_w', cmap='Blues',
    linewidth=0.6, edgecolor='gray', legend=True,
    legend_kwds={'label': "Median Household Income ($)"},
    ax=axes[1]
)
axes[1].set_title("Geographic Hotspot of Household Income (by Police District)", fontsize=14, fontweight='bold')
axes[1].axis('off')

plt.tight_layout()
plt.show()

"""#### 3.2 Summary

The spatial analysis reveals clustering of crime incidents in Boston. The Folium heatmap highlights concentrated hotspots in Dorchester, parts of Roxbury and Mattapan, with additional density visible in Downtown and South Boston.

Overlaying socioeconomic indicators strengthens this observation. District-level poverty rates reach above 25–28% in central neighborhoods, which correspond closely to the high-crime hotspots. In contrast, districts with median household incomes above $110,000 display both lower poverty burdens and fewer intense crime clusters. The results provide evidence that Boston’s crime distribution is geographically unequal, with disadvantaged districts disproportionately burdened by both higher poverty and higher crime density.

### 4. Crime Timing, Exploring Characteristics of Crimes Committed at Different Times


---

#### 4.1 Night-time Crime Share by District

This analysis measures how crime patterns vary by time of day across Boston districts. Crime incident times are extracted and classified as “night-time” (8 PM-6 AM). The code then calculates each district's night-time crime share as a percentage of its total incidents and visualizes the results in a bar chart ranked by night-time concentration.
"""

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import matplotlib.ticker as mtick

# Ensure date column is in datetime format
crime_incident['OCCURRED_ON_DATE'] = pd.to_datetime(crime_incident['OCCURRED_ON_DATE'], errors='coerce')

# Extract hour from datetime
crime_incident['hour'] = crime_incident['OCCURRED_ON_DATE'].dt.hour

# Define night-time: 20:00–23:59 and 00:00–06:00
crime_incident['is_night'] = crime_incident['hour'].apply(lambda x: (x >= 20) or (x <= 6))

# Group by district: count total cases and night-time cases
district_stats = (crime_incident
                  .groupby('DISTRICT')
                  .agg(total_cases=('INCIDENT_NUMBER','count'),
                       night_cases=('is_night','sum'))
                  .reset_index())

# Calculate night-time crime share
district_stats['night_share'] = district_stats['night_cases'] / district_stats['total_cases'] * 100

# Sort districts by night-time crime share
sorted_stats = district_stats.sort_values('night_share', ascending=False).reset_index(drop=True)

sns.set_theme(style="whitegrid")
plt.figure(figsize=(12, 7))

ax = sns.barplot(
    data=sorted_stats,
    y='DISTRICT', x='night_share',
    hue='DISTRICT', palette='Blues_d', legend=False
)

ax.set_title('Night-time Crime Share by District', fontsize=18, fontweight='bold', pad=12)
ax.set_xlabel('Night-time Crime Share (%)', fontsize=13)
ax.set_ylabel('District', fontsize=13)

# Format x-axis as percentage
ax.xaxis.set_major_formatter(mtick.PercentFormatter(xmax=100))

# Add percentage labels at the end of bars
for p in ax.patches:
    width = p.get_width()
    y = p.get_y() + p.get_height()/2
    ax.text(width + max(sorted_stats['night_share'])*0.01, y,
            f"{width:.1f}%", va='center', ha='left', fontsize=11, color='#333')

# Highlight Top-1 district with the highest night-time share
if len(ax.patches) > 0:
    ax.patches[0].set_facecolor('#1f77b4')

# Minor aesthetic adjustments
sns.despine(left=True, bottom=False)
plt.tight_layout()
plt.show()

"""Answer: Night-time crimes make up roughly one-third of total incidents across Boston districts, with the highest shares observed in A1 (36.3%), A7 (35.9%), and B3 (35.2%). These districts—covering central and waterfront areas—show slightly higher night-time activity compared to residential zones like E5 (28.2%). Overall, the pattern suggests that commercial and nightlife-heavy districts experience more late-hour crime incidents.

#### 4.2 Does a community's economic status influence temporal distribution patterns?

This analysis aims to investigate whether community economic conditions influence the temporal distribution patterns of criminal incidents. By categorizing areas into four income tiers (low-income, lower-middle-income, upper-middle-income, high-income), it examines the distribution patterns of crime across different income groups at both the monthly and weekly dimensions. The methodology employs intra-group standardization to neutralize differences in total crime volumes across income groups, focusing instead on the relative distribution patterns of criminal activity within specific time periods and days of the week. This approach aims to uncover potential correlations between economic factors and temporal patterns of crime.
"""

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

tmp_time = crime_income.copy(deep=True)

# Ensure datetime conversion
if 'OCCURRED_ON_DATE' in tmp_time.columns:
    tmp_time['OCCURRED_ON_DATE'] = pd.to_datetime(tmp_time['OCCURRED_ON_DATE'], errors='coerce')
    tmp_time = tmp_time.dropna(subset=['OCCURRED_ON_DATE'])
else:
    raise KeyError("Column 'OCCURRED_ON_DATE' not found in crime_income dataframe.")

# Extract Month & Weekday
tmp_time['Month'] = tmp_time['OCCURRED_ON_DATE'].dt.month_name()
tmp_time['Weekday'] = tmp_time['OCCURRED_ON_DATE'].dt.day_name()

# Identify Income Column
possible_income_cols = [c for c in tmp_time.columns if 'income' in c.lower()]
if not possible_income_cols:
    raise KeyError("No income-related column found in tmp_time. Please check the dataset.")
income_col = possible_income_cols[0]

# Create income quartiles
tmp_time['Income_Level'] = pd.qcut(
    tmp_time[income_col],
    q=4,
    labels=['Low', 'Lower-Mid', 'Upper-Mid', 'High']
)

# Define month & weekday order
month_order = [
    'January','February','March','April','May','June',
    'July','August','September','October','November','December'
]
weekday_order = [
    'Monday','Tuesday','Wednesday','Thursday','Friday','Saturday','Sunday'
]
tmp_time['Month'] = pd.Categorical(tmp_time['Month'], categories=month_order, ordered=True)
tmp_time['Weekday'] = pd.Categorical(tmp_time['Weekday'], categories=weekday_order, ordered=True)

# Monthly pattern: normalized within income groups
monthly_trends = (
    tmp_time.groupby(['Income_Level', 'Month'], observed=False)
            .size()
            .reset_index(name='Crime_Count')
)
monthly_trends['Share'] = (
    monthly_trends.groupby('Income_Level', observed=False)['Crime_Count']
    .transform(lambda x: (x / x.sum()) * 100)
)

# Weekday pattern: normalized within income groups
weekday_trends = (
    tmp_time.groupby(['Income_Level', 'Weekday'], observed=False)
            .size()
            .reset_index(name='Crime_Count')
)
weekday_trends['Share'] = (
    weekday_trends.groupby('Income_Level', observed=False)['Crime_Count']
    .transform(lambda x: (x / x.sum()) * 100)
)

# Monthly Pattern Visualization
sns.set_style("whitegrid")
palette = ['#e76f51', '#f4a261', '#2a9d8f', '#264653']

plt.figure(figsize=(9,5))
sns.lineplot(
    data=monthly_trends,
    x='Month', y='Share', hue='Income_Level', marker='o',
    lw=2.2, alpha=0.9, palette=palette
)
plt.title('Monthly Crime Distribution by Income Level (Within Each Group)', fontsize=13, weight='bold')
plt.ylabel('Share of Annual Crimes (%)')
plt.xlabel('Month')
plt.xticks(rotation=45)
plt.ylim(5, 12)
plt.grid(alpha=0.25)
plt.axvspan('June', 'September', color='orange', alpha=0.08, label='Summer')
plt.legend(title='Income Level', loc='upper right')
plt.tight_layout()
plt.show()

# Weekday Pattern Visualization
plt.figure(figsize=(8,4))
sns.lineplot(
    data=weekday_trends,
    x='Weekday', y='Share', hue='Income_Level', marker='o',
    lw=2.2, alpha=0.9, palette=palette
)
plt.title('Day-of-Week Crime Distribution by Income Level (Within Each Group)', fontsize=13, weight='bold')
plt.ylabel('Share of Weekly Crimes (%)')
plt.xlabel('Day of Week')
plt.xticks(rotation=45)
plt.ylim(8, 20)
plt.grid(alpha=0.25)
plt.legend(title='Income Level', loc='upper right')
plt.tight_layout()
plt.show()

# Summary Tables
display(monthly_trends.pivot(index='Month', columns='Income_Level', values='Share').round(2))
display(weekday_trends.pivot(index='Weekday', columns='Income_Level', values='Share').round(2))

"""Answer:

Crime rates rise across all income groups during the summer months, but seasonal fluctuations are most pronounced in low-income areas. Regarding weekday distribution, low-income areas exhibit higher crime rates on weekdays (Monday through Friday), while high-income areas show relative peaks on Fridays and Saturdays.

#### 4.3 Summary

Time-based crime analysis reveals that nighttime crime in Boston exhibits distinct spatial differentiation. Areas with active commercial and nightlife activities (such as Zones A1, A7, and B3) account for over 35% of nighttime crimes, significantly higher than predominantly residential zones (such as Zone E5). Regarding temporal distribution patterns, all income groups experience increased crime rates during summer, though seasonal fluctuations are most pronounced in low-income areas. Within weekly distributions, low-income areas see crime concentrated on weekdays, while high-income areas exhibit relative peaks on Fridays and Saturdays. Collectively, these findings indicate that the temporal distribution of crime is influenced by both neighborhood functional attributes and socioeconomic characteristics.

### 5. Income Disparity, Examining How Income Levels Within Different Areas Impact Crime


---

#### 5.1  What is the relationship between income inequality within a community (income distribution across socioeconomic strata) and its crime rate?

This code examines how income inequality relates to crime rates across Boston districts. It first creates a clean copy of the dataset and ensures that each district is labeled as either high- or low-income using the median household income as a threshold. It then calculates descriptive statistics for both groups and visualizes differences using boxplots and bar charts. Finally, a t-test compares average crime levels between high- and low-income districts to test whether the observed difference is statistically significant.
"""

import seaborn as sns
import matplotlib.pyplot as plt
import pandas as pd
from scipy.stats import ttest_ind

# Create a safe copy
df_crime = district_crime.copy()

# Ensure Low_Income_Flag exists
if 'Low_Income_Flag' not in df_crime.columns:
    if 'district_ses' in globals() and 'DISTRICT' in district_ses.columns:
        # Merge income flag based on district
        ses_income = district_ses[['DISTRICT', 'Median_Household_Income_weighted']].copy()
        income_threshold = ses_income['Median_Household_Income_weighted'].median()
        ses_income['Low_Income_Flag'] = (ses_income['Median_Household_Income_weighted'] < income_threshold).astype(int)
        df_crime = df_crime.merge(ses_income[['DISTRICT', 'Low_Income_Flag']], on='DISTRICT', how='left')
    else:
        raise KeyError("`Low_Income_Flag` not found and `district_ses` not available for merge.")

# Ensure dtype
df_crime['Low_Income_Flag'] = df_crime['Low_Income_Flag'].fillna(0).astype(int)

# Descriptive statistics
crime_summary = df_crime.groupby('Low_Income_Flag')['total_crimes'].agg(['mean', 'median', 'std', 'count'])
print("Crime Summary by Income Group:")
print(crime_summary, "\n")

# Boxplot
plt.figure(figsize=(7, 5))
sns.boxplot(data=df_crime, x='Low_Income_Flag', y='total_crimes', palette='coolwarm')
plt.title('Crime Distribution by Income Group', fontsize=14, pad=10)
plt.xlabel('Income Group (0 = High Income, 1 = Low Income)', fontsize=12)
plt.ylabel('Total Crimes', fontsize=12)
plt.tight_layout()
plt.show()

# Bar chart
plt.figure(figsize=(7, 5))
sns.barplot(data=df_crime, x='Low_Income_Flag', y='total_crimes', ci='sd', palette='coolwarm')
plt.title('Average Total Crimes by Income Group', fontsize=14, pad=10)
plt.xlabel('Income Group (0 = High Income, 1 = Low Income)', fontsize=12)
plt.ylabel('Average Total Crimes', fontsize=12)
plt.tight_layout()
plt.show()

# T-test
low_income_crime = df_crime[df_crime['Low_Income_Flag'] == 1]['total_crimes']
high_income_crime = df_crime[df_crime['Low_Income_Flag'] == 0]['total_crimes']

t_stat, p_value = ttest_ind(low_income_crime, high_income_crime, equal_var=False)
print(f" T-test Results: t-statistic = {t_stat:.3f}, p-value = {p_value:.4f}")

# Interpretation
if p_value < 0.05:
    print("\n Statistically significant difference found:")
    print("Low-income districts have different (likely higher) crime rates than high-income ones.")
else:
    print("\n No statistically significant difference detected between income groups.")

"""The results show that low-income districts experience noticeably higher and more variable crime levels than high-income areas. Both boxplots and bar charts confirm this trend, and the t-test result (p < 0.05) indicates that the difference is statistically significant. Overall, the findings suggest that income inequality is closely linked to higher crime rates across Boston districts.

#### 5.2  Divide socioeconomic variables into quartiles and compare crime distributions across quartiles.

This analysis explores how socioeconomic disparities—poverty, education, unemployment, and income—relate to violent crime rates across Boston's districts.
Key socioeconomic indicators are extracted from ACS data and merged with district-level crime data via a geographic crosswalk. Each variable is divided into quartiles, and boxplots are generated to compare violent crime rates across these socioeconomic groups. The visualization highlights how differences in income, education, and employment correspond to variations in crime concentration.
"""

import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt

# Build new poverty dataframe with education & unemployment
poverty_vars = {
    "S1701_C02_001E": "Poverty_Rate_Total",
    "S1701_C02_012E": "Less_HS_Education_Pct",
    "S1701_C02_037E": "Unemployment_Pct"
}

poverty_clean = poverty_status[["GEO_ID", "NAME"] + list(poverty_vars.keys())].copy()
poverty_clean = poverty_clean.rename(columns=poverty_vars)
poverty_clean["GEOID"] = poverty_clean["GEO_ID"].astype(str).str.extract(r"(\d{11})")

# Convert to numeric
for col in ["Poverty_Rate_Total", "Less_HS_Education_Pct", "Unemployment_Pct"]:
    poverty_clean[col] = pd.to_numeric(poverty_clean[col], errors="coerce")

poverty_clean = poverty_clean.dropna(subset=["Poverty_Rate_Total"])

# Merge poverty, income, and crosswalk
income["GEOID"] = income["GEO_ID"].astype(str).str.extract(r"(\d{11})")
income_small = income[["GEOID", "S1901_C01_012E"]].rename(
    columns={"S1901_C01_012E": "Median_Household_Income"}
)
income_small["Median_Household_Income"] = pd.to_numeric(income_small["Median_Household_Income"], errors="coerce")

# Merge with poverty_clean
ses_tract = poverty_clean.merge(income_small, on="GEOID", how="inner")

# Attach district from crosswalk
tract_to_district["geoid20"] = tract_to_district["geoid20"].astype(str)
ses_district = ses_tract.merge(tract_to_district, left_on="GEOID", right_on="geoid20", how="inner")

# Aggregate to district level
district_ses_full = (
    ses_district.groupby("DISTRICT", as_index=False)
    .agg(
        Poverty_Rate_Total=("Poverty_Rate_Total", "mean"),
        Less_HS_Education_Pct=("Less_HS_Education_Pct", "mean"),
        Unemployment_Pct=("Unemployment_Pct", "mean"),
        Median_Household_Income=("Median_Household_Income", "mean")
    )
)

# Merge with crime data
district_crime = (
    crime_incident.groupby("DISTRICT", as_index=False)
    .agg(Crime_Count=("INCIDENT_NUMBER", "count"))
)
district_ses_full = district_ses_full.merge(district_crime, on="DISTRICT", how="left")

# Add population base (if available from previous district_ses)
if "pop_total" in district_ses.columns:
    district_ses_full = district_ses_full.merge(
        district_ses[["DISTRICT", "pop_total"]],
        on="DISTRICT", how="left"
    )
    district_ses_full["Crime_per_1k"] = district_ses_full["Crime_Count"] / district_ses_full["pop_total"] * 1000
else:
    # fallback: normalized by district mean
    district_ses_full["Crime_per_1k"] = (district_ses_full["Crime_Count"] /
                                         district_ses_full["Crime_Count"].sum()) * 1000

# Create quartiles for SES variables
district_ses_full["Poverty_Q"] = pd.qcut(district_ses_full["Poverty_Rate_Total"], 4,
                        labels=["Q1 Lowest","Q2","Q3","Q4 Highest"])
district_ses_full["Education_Q"] = pd.qcut(district_ses_full["Less_HS_Education_Pct"], 4,
                        labels=["Q1 Lowest","Q2","Q3","Q4 Highest"])
district_ses_full["Unemployment_Q"] = pd.qcut(district_ses_full["Unemployment_Pct"], 4,
                        labels=["Q1 Lowest","Q2","Q3","Q4 Highest"])
district_ses_full["Income_Q"] = pd.qcut(district_ses_full["Median_Household_Income"], 4,
                        labels=["Q4 Highest","Q3","Q2","Q1 Lowest"])

# Define plotting and delta summary function
import matplotlib.pyplot as plt
import seaborn as sns

def draw_quartile_boxplots(df):
    fig, axes = plt.subplots(2, 2, figsize=(12, 8))
    plt.subplots_adjust(hspace=0.35, wspace=0.25)

    plots = [
        ("Poverty_Q", "Poverty Rate", False, axes[0,0]),
        ("Education_Q", "Low Education Rate", False, axes[0,1]),
        ("Unemployment_Q", "Unemployment Rate", False, axes[1,0]),
        ("Income_Q", "Median Household Income", True, axes[1,1]),
    ]

    for quartile_col, label, reverse, ax in plots:
        order = ["Q1 Lowest","Q2","Q3","Q4 Highest"] if not reverse else ["Q4 Highest","Q3","Q2","Q1 Lowest"]
        sns.boxplot(
            data=df,
            x=quartile_col,
            y="Crime_per_1k",
            hue=quartile_col,
            order=order,
            palette="coolwarm",
            legend=False,
            ax=ax
        )
        ax.set_title(f"{label} Quartiles vs Crime Rate", fontsize=11, weight="semibold")
        ax.set_xlabel("")
        ax.set_ylabel("Crime per 1,000 Residents")

        med = df.groupby(quartile_col, observed=True)["Crime_per_1k"].median()
        q1, q4 = med.iloc[0], med.iloc[-1]
        delta = q4 - q1
        ratio = q4 / q1 if q1 > 0 else np.nan
        ax.text(0.05, 0.9, f"Δ={delta:.1f}, {ratio:.2f}×", transform=ax.transAxes,
                fontsize=9, color="black", bbox=dict(boxstyle="round,pad=0.3", fc="white", ec="gray", alpha=0.7))

    fig.suptitle("Quartile Analysis of Socioeconomic Disparities and Crime Rates (District Level)", fontsize=14, weight="bold")
    plt.show()

    print("=== Median Δ (Q4 - Q1) Summary ===")
    for col, label, rev, _ in plots:
        med = df.groupby(col, observed=True)["Crime_per_1k"].median()
        q1, q4 = med.iloc[0], med.iloc[-1]
        delta = q4 - q1
        ratio = q4 / q1 if q1 > 0 else np.nan
        print(f"{label}: median(Q4)={q4:.2f}, median(Q1)={q1:.2f}, Δ={delta:.2f}, ratio={ratio:.2f}x")

draw_quartile_boxplots(district_ses_full)

"""Answer:

The crime rate in the region with the highest poverty rate is 1.78 times that of the region with the lowest poverty rate; the crime rate in the region with the highest unemployment rate is 1.86 times that of the region with the lowest unemployment rate; the crime rate in the region with the highest income is 41% lower than that of the region with the lowest income. The data confirms: the poorer the socioeconomic conditions, the higher the crime rate.

#### 5.3 Summary

The analyses consistently demonstrate a strong link between socioeconomic inequality and crime prevalence across Boston's districts. Statistical comparisons reveal that low-income areas experience significantly higher and more variable crime levels than wealthier neighborhoods, a difference confirmed by a t-test wher p < 0.05. This finding establishes that income inequality is not only correlated with but may actively contribute to elevated crime rates.

When socioeconomic indicators such as poverty, unemployment, education, and income are divided into quartiles, the patterns become even clearer. Districts in the highest poverty and unemployment quartiles exhibit crime rates nearly twice as high as those in the lowest quartiles, while high-income regions show crime rates over 40% lower than their low-income counterparts.

These results provide robust empirical evidence that poorer socioeconomic conditions—particularly low income, limited education, and high unemployment—are strongly associated with increased crime rates. The findings underscore the importance of addressing underlying economic disparities to improve community safety and reduce crime in urban areas like Boston.

### 6. The Evolution of Socioeconomic Conditions and Crime Over Three Years (2020–2022)



---

#### 6.1 How did the relationship between socioeconomic conditions and crime rates evolve across Boston communities over time?

This study aims to analyze the evolving dynamic relationship between socioeconomic conditions, represented by median household income and poverty rates, and crime rates across Boston neighborhoods from 2020 to 2022. By comparing annual trends in income levels, poverty rates, and the number of violent and property crimes across different areas, it examines whether the correlation between these factors strengthens, weakens, or remains stable over time, while identifying patterns of interaction between socioeconomic shifts and the geographic distribution of crime..
"""

import pandas as pd
import geopandas as gpd
import numpy as np
import plotly.express as px
import plotly.graph_objects as go
from shapely.geometry import Point

# Create geographic crosswalk
url = "https://gisportal.boston.gov/arcgis/rest/services/PublicSafety/OpenData/MapServer/5/query?where=1=1&outFields=*&f=geojson"
districts = gpd.read_file(url).to_crs("EPSG:4326")

tracts = pd.read_csv("https://raw.githubusercontent.com/paddington-L831/Intro-to-Data-Analystics1/refs/heads/main/Census_Tracts_in_Boston.csv")
tracts_gdf = gpd.GeoDataFrame(
    tracts, geometry=[Point(xy) for xy in zip(tracts["intptlon20"], tracts["intptlat20"])],
    crs="EPSG:4326"
)

crosswalk = gpd.sjoin(
    tracts_gdf[["geoid20", "geometry"]],
    districts[["DISTRICT", "geometry"]],
    how="left", predicate="within"
)[["geoid20", "DISTRICT"]].drop_duplicates().reset_index(drop=True)

crosswalk['geoid20'] = crosswalk['geoid20'].astype(str)

# Data URLs
crime_files = {
    2020: "https://raw.githubusercontent.com/paddington-L831/Intro-to-Data-Analystics1/refs/heads/main/incident%20of%202020.csv",
    2021: "https://raw.githubusercontent.com/paddington-L831/Intro-to-Data-Analystics1/refs/heads/main/incident%20of%202021.csv",
    2022: "https://raw.githubusercontent.com/paddington-L831/Intro-to-Data-Analystics1/refs/heads/main/incident%20of%202022.csv"
}

poverty_files = {
    2020: "https://raw.githubusercontent.com/paddington-L831/Intro-to-Data-Analystics1/refs/heads/main/ACSST5Y2020.S1701-Data.csv",
    2021: "https://raw.githubusercontent.com/paddington-L831/Intro-to-Data-Analystics1/refs/heads/main/ACSST5Y2021.S1701-Data.csv",
    2022: "https://raw.githubusercontent.com/paddington-L831/Intro-to-Data-Analystics1/refs/heads/main/ACSST5Y2022.S1701-Data.csv"
}

income_files = {
    2020: "https://raw.githubusercontent.com/paddington-L831/Intro-to-Data-Analystics1/refs/heads/main/ACSST5Y2020.S1901-Data.csv",
    2021: "https://raw.githubusercontent.com/paddington-L831/Intro-to-Data-Analystics1/refs/heads/main/ACSST5Y2021.S1901-Data.csv",
    2022: "https://raw.githubusercontent.com/paddington-L831/Intro-to-Data-Analystics1/refs/heads/main/ACSST5Y2022.S1901-Data.csv"
}

# Process crime data
def classify_crime_boston(description):
    if pd.isna(description):
        return 'Other'

    desc_upper = str(description).upper()

    violent_keywords = [
        'ASSAULT', 'BATTERY', 'ASSAULT & BATTERY', 'AGGRAVATED ASSAULT',
        'ROBBERY', 'ARMED ROBBERY', 'CARJACKING',
        'HOMICIDE', 'MURDER', 'MANSLAUGHTER',
        'RAPE', 'SEXUAL ASSAULT', 'INDECENT ASSAULT',
        'WEAPONS', 'FIREARM', 'BALLISTICS', 'SHOOTING',
        'THREATS', 'INTIMIDATING'
    ]

    property_keywords = [
        'LARCENY', 'THEFT', 'LARCENY FROM', 'SHOPLIFTING', 'STOLEN PROPERTY',
        'RECEIVING STOLEN', 'LARCENY OF', 'BICYCLE THEFT',
        'BURGLARY', 'BREAKING & ENTERING', 'B & E',
        'AUTO THEFT', 'MOTOR VEHICLE THEFT', 'MV THEFT',
        'FRAUD', 'FORGERY', 'COUNTERFEITING', 'CREDIT CARD FRAUD',
        'VANDALISM', 'MALICIOUS DAMAGE', 'ARSON',
        'PROPERTY - LOST', 'PROPERTY - FOUND', 'TRESPASSING'
    ]

    for keyword in violent_keywords:
        if keyword in desc_upper:
            return 'Violent Crime'

    for keyword in property_keywords:
        if keyword in desc_upper:
            return 'Property Crime'

    return 'Other'

def process_crime_data():
    all_crime = []

    for year, url in crime_files.items():
        print(f"Processing crime data {year}...")
        try:
            df = pd.read_csv(url)
            df['year'] = year

            df['crime_type'] = df['OFFENSE_DESCRIPTION'].apply(classify_crime_boston)

            crime_counts = df['crime_type'].value_counts()
            print(f"Crime type distribution:")
            for crime_type, count in crime_counts.items():
                percentage = count/len(df)*100
                print(f"  {crime_type}: {count} records ({percentage:.1f}%)")

            all_crime.append(df)

        except Exception as e:
            print(f"Error: {e}")
            continue

    return pd.concat(all_crime, ignore_index=True) if all_crime else None

# Process socioeconomic data
def find_column_by_pattern(df, patterns):
    for pattern in patterns:
        matching_cols = [col for col in df.columns if pattern in col]
        if matching_cols:
            return matching_cols[0]
    return None

def process_socioeconomic_data():
    all_socio = []

    for year in [2020, 2021, 2022]:
        try:
            poverty_df = pd.read_csv(poverty_files[year])
            income_df = pd.read_csv(income_files[year])

            socio_df = poverty_df[['GEO_ID', 'NAME']].copy()

            total_pop_col = find_column_by_pattern(poverty_df, ['S1701_C01_001', 'C01_001'])
            poverty_pop_col = find_column_by_pattern(poverty_df, ['S1701_C02_001', 'C02_001'])
            income_col = find_column_by_pattern(income_df, ['S1901_C01_012', 'C01_012'])

            if total_pop_col:
                socio_df['total_population'] = poverty_df[total_pop_col]
            if poverty_pop_col:
                socio_df['poverty_population'] = poverty_df[poverty_pop_col]
            if income_col:
                socio_df['median_income'] = income_df[income_col]

            for col in ['total_population', 'poverty_population', 'median_income']:
                if col in socio_df.columns:
                    socio_df[col] = pd.to_numeric(socio_df[col], errors='coerce')

            if 'total_population' in socio_df.columns and 'poverty_population' in socio_df.columns:
                socio_df['poverty_rate'] = (socio_df['poverty_population'] / socio_df['total_population']) * 100

            socio_df['geoid20'] = socio_df['GEO_ID'].str.extract(r'US(\d+)')
            socio_df['geoid20'] = socio_df['geoid20'].astype(str)

            socio_df['year'] = year
            all_socio.append(socio_df)

        except Exception as e:
            print(f"Error processing {year}: {e}")
            continue

    return pd.concat(all_socio, ignore_index=True) if all_socio else None

# Process data
crime_data = process_crime_data()
socio_data = process_socioeconomic_data()

# Data merging and aggregation
if crime_data is not None and socio_data is not None:
    socio_with_district = socio_data.merge(crosswalk, on='geoid20', how='inner')

    crime_agg = crime_data.groupby(['DISTRICT', 'year', 'crime_type']).size().reset_index(name='crime_count')

    final_data = crime_agg.merge(
        socio_with_district[['DISTRICT', 'year', 'median_income', 'poverty_rate', 'total_population']],
        on=['DISTRICT', 'year'],
        how='inner'
    )

    nan_count = final_data['poverty_rate'].isna().sum()

    final_data_clean = final_data.dropna(subset=['poverty_rate']).copy()

    # Create visualization
    viz_data = final_data_clean[final_data_clean['crime_type'].isin(['Violent Crime', 'Property Crime'])].copy()

    if len(viz_data) > 0:
        districts = sorted(viz_data['DISTRICT'].unique())

        dark_colors = [
            '#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd',
            '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf',
            '#393b79', '#5254a3', '#6b6ecf', '#9c9ede', '#637939'
        ]

        fig = px.scatter(
            viz_data,
            x="median_income",
            y="crime_count",
            animation_frame="year",
            animation_group="DISTRICT",
            color="DISTRICT",
            size="poverty_rate",
            symbol="crime_type",
            hover_name="DISTRICT",
            hover_data={
                'median_income': ':,.0f',
                'poverty_rate': ':.1f%',
                'crime_count': True,
                'total_population': ':,.0f'
            },
            size_max=25,
            opacity=0.9,
            color_discrete_sequence=dark_colors,
            symbol_sequence=['circle', 'square'],
            title="<b>Boston: Income vs Crime Counts (2020-2022)</b><br>" +
                  "<sub>Point size = Poverty Rate &nbsp;&nbsp; ○ = Violent Crime &nbsp;&nbsp; □ = Property Crime</sub>",
            labels={
                "median_income": "<b>Median Household Income ($)</b>",
                "crime_count": "<b>Number of Crimes</b>",
                "DISTRICT": "<b>Census Tract</b>",
                "crime_type": "<b>Crime Type</b>",
                "poverty_rate": "<b>Poverty Rate (%)</b>"
            },
            category_orders={
                "crime_type": ["Violent Crime", "Property Crime"],
                "DISTRICT": districts
            }
        )

        fig.update_layout(
            width=1000,
            height=700,
            xaxis_title="<b>Median Household Income ($)</b>",
            yaxis_title="<b>Number of Crimes</b>",
            showlegend=True,
            legend=dict(
                title="<b>Census Tracts</b>",
                orientation="v",
                yanchor="top",
                y=0.99,
                xanchor="left",
                x=1.02,
                bgcolor='rgba(255,255,255,0.95)',
                bordercolor='black',
                borderwidth=2,
                font=dict(size=11, color='black')
            ),
            font=dict(size=12, family="Arial", color='black'),
            plot_bgcolor='rgba(248,248,248,0.8)',
            paper_bgcolor='white',
            xaxis=dict(
                showgrid=True,
                gridwidth=1,
                gridcolor='lightgray',
                zeroline=True,
                zerolinewidth=2,
                zerolinecolor='black',
                showline=True,
                linewidth=2,
                linecolor='black'
            ),
            yaxis=dict(
                showgrid=True,
                gridwidth=1,
                gridcolor='lightgray',
                zeroline=True,
                zerolinewidth=2,
                zerolinecolor='black',
                showline=True,
                linewidth=2,
                linecolor='black'
            )
        )

        fig.update_traces(
            marker=dict(
                line=dict(width=2, color='black'),
                sizemin=4
            ),
            selector=dict(mode='markers')
        )

        x_min = max(viz_data['median_income'].min() * 0.8, 0)
        x_max = viz_data['median_income'].max() * 1.1
        y_max = viz_data['crime_count'].max() * 1.1

        fig.update_xaxes(range=[x_min, x_max])
        fig.update_yaxes(range=[0, y_max])

        fig.show()

"""#### 6.2 Summary

Poverty rates exhibit a pronounced crime amplification effect in low-income communities. High-poverty areas cluster on the left side of the chart, forming a compound dilemma of “low income—high poverty—high crime.” Even among communities with similar incomes, disparities in poverty levels lead to significant stratification in crime rates, indicating that poverty is a key risk factor independent of income.
Crime types exhibit pronounced regional differentiation. Violent crimes cluster in low-income areas, while property crimes distribute relatively evenly across both high- and low-income zones. This indicates low-income communities face dual criminal pressures, whereas high-income areas primarily endure threats from property crimes.
This crime-economic relationship demonstrates strong temporal stability. The overall distribution pattern remained highly consistent over three years, with minor fluctuations in individual communities failing to alter the global structure—confirming its nature as a deep-seated, structural issue.
From a risk zoning perspective: High-risk zones such as A1, A7, B2, and B3 exhibit concurrent characteristics of low income, high poverty, and high crime rates; Moderate-risk zones like C6, C11, and D4 maintain manageable crime levels; Low-risk zones including E13 and E18 predominantly experience property crimes with rare occurrences of violent offenses.

## VI. Conclusion

---
---

**Key Findings**

*   Crime rates demonstrate a strong negative correlation with income levels, with low-income communities experiencing substantially higher crime volumes than affluent areas. Poverty rates independently amplify crime risk beyond income effects.

*   Crime types show distinct spatial patterns: violent crimes concentrate in low-income neighborhoods, while property crimes distribute more evenly across communities. Shooting incidents exhibit extreme geographic concentration in districts B2, B3, and C11.

*   Spatiotemporal analysis confirms significant overlap between crime hotspots and high-poverty areas. Nighttime crime predominates in commercial districts, and seasonal patterns affect all areas but show the strongest fluctuations in low-income neighborhoods.

*   Community-level income inequality further correlates with crime rates, with high-poverty areas experiencing nearly double the crime rates of low-poverty districts.
The stable relationship between crime and socioeconomic factors throughout the three years indicates these are structural patterns requiring systemic solutions.

**Policy Recommandations**

These findings indicate that effective crime reduction requires addressing underlying socioeconomic disparities alongside traditional law enforcement. We recommend:
*  Implementing geographically targeted interventions in high-risk areas
*  Developing economic opportunity programs in high-poverty communities
*  Designing crime prevention strategies that account for spatial and temporal patterns
*  Fostering cross-agency collaborations, integrating public safety with economic development

**Closing Perspective**

The persistent nature of these crime-socioeconomic relationships underscores that crime in Boston follows predictable gradients rather than random distribution. By recognizing these structural patterns, policymakers can advance beyond reactive measures toward evidence-based strategies that address both symptoms and root causes of urban crime. Future efforts should focus on evaluating targeted interventions in priority districts to build upon these foundational insights.

## VII. Challenges

---
---

1.  Throughout the analysis, several data-related challenges emerged, primarily
concerning data quality, alignment, and integration across multiple sources. One major challenge was the inconsistency of variable names and formats across ACS socioeconomic datasets (S1701 and S1901 tables). Each year’s dataset used slightly different column codes or structures, requiring automated pattern matching and column detection functions to ensure accurate extraction of poverty, income, and education variables. Additionally, missing or non-numeric entries—particularly in socioeconomic indicators like median income and poverty rate—necessitated careful cleaning, coercion to numeric types, and the use of imputation or filtering to prevent data loss in regression and correlation analyses.

2.  Another significant challenge was geographic alignment. Because the Boston Police Districts and U.S. Census tracts use different spatial units, a crosswalk file had to be created by performing centroid-based spatial joins using geopandas. This process occasionally produced mismatches for tracts lying near district borders, which were resolved through manual inspection and nearest-neighbor reassignment.

3.  The crime incident data also presented issues of scale and standardization. Over 100,000 records per year contained variations in offense descriptions, date formats, and missing geographic identifiers. These were addressed through text normalization, regular expression-based categorization, and the use of robust merge keys. Finally, data size posed computational challenges in Google Colab, requiring selective aggregation at the district level and use of optimized joins to manage memory efficiently.

4.  Despite these obstacles, careful preprocessing, modular cleaning functions, and validation at each step ensured that the final dataset was consistent, interpretable, and ready for statistical and spatial analysis. These cleaning and harmonization efforts were critical in enabling reliable insights into the socioeconomic correlates of crime across Boston.

5.  During the creation of the three-year dynamic change map, we initially used only two colors to represent the two major crime categories, with all census tracts colored identically. However, we found this approach failed to effectively illustrate the trajectory of change over the three years. Consequently, we decided to assign distinct colors to each census tract and use different shapes to denote the two crime categories. This allows for clearer observation of the movement patterns within each census tract.

## VIII. References

---
---

*   Intro to Animations in Python: https://plotly.com/python/animations/
*   GeoPandas: Python Tools for Geographic Data: https://geopandas.org/en/stable/
*   Geometry Shapely 2.1.2 documentation: https://shapely.readthedocs.io/en/stable/geometry.html
*   Folium: Python Data Visualization Library for Interactive Maps: https://python-visualization.github.io/folium/latest/
*   Seaborn: Statistical Data Visualization: https://seaborn.pydata.org/
*   Data Structures for Statistical Computing in Python: https://pandas.pydata.org/.
*   Python (Official Website): https://www.python.org/
*   W3Schools: Python Tutorial: https://www.w3schools.com/python/

## VIIII. Generative AI

---
---

When working on the project, we utilized Generative AI tools to assist with various aspects of our work. Below is the detailed account of how the Generative AI tools were used:

1.   Code Debugging and Charts Optimizing: We used Google Gemini and ChatGPT to give us advice on resolving errors in the code and debugging issues. For improving visualization, we asked GPT to get suggestions on how to create clear and appealing charts. It suggested changes to the code to improve the colors, borders and plots.

2.   Clarity Edits & Answer Review: ChatGPT helped us rephrase sentences for readability and coherence, reduce redundancy, and tighten topic sentences—without adding new analysis or claims.

3.   Proofreading & Grammar Checks: We used Grammarly to correct grammar, punctuation, and style issues. Final edits were reviewed and approved by our team.

Our team has adhered to academic integrity standards throughout the process, and all analysis was conducted independently and not generated by AI.
"""